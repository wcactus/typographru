<?php

namespace Wcactus\TypographRu;

/**
 * UTF-8 screen typography processor.
 *
 * Символы, которые упоминаются в этой библиотеке (для справочных целей):
 * UCS-2	UTF-8		Entity	Название		Описание
 * ======	============	=======	=======================	=======================
 * \uFFFC	\xEF\xBF\xBC	-	Object Replacement	Спец-символ для подстановки
 * \u00A0	\xC2\xA0	nbsp	No Break Space		Неразрывный пробел
 * \u2013	\xE2\x80\x93	ndash	En Dash			Короткое тире
 * \u2014	\xE2\x80\x94	mdash	Em Dash			Длинное тире
 * \u2010	\xE2\x80\x90	-	Hyphen			Дефис
 * \u2011	\xE2\x80\x91	-	No Break Hyphen		Неразрывный дефис
 * \u2026	\xE2\x80\xA6	hellip	Horizontal Ellipsis	Троеточие
 * \u8201	\xE2\x80\x89	thinsp	узкий пробел		Тонкая шпация
 *
 * \u00AB	\xC2\xAB	laquo	Left Angle QUOtation	Левые двойные угловые (ёлочки)
 * \u00BB	\xC2\xBB	raquo	Right Angle QUOtation	Правые двойные угловые (ёлочки)
 * \u2039	\xE2\x80\xB9	lsaquo	Left Single Angle QUO	Левые одинарные угловые (уголки)
 * \u203A	\xE2\x80\xBA	rsaquo	Right Single Angle QUO  Правые одинарные угловые (уголки)
 * \u201E	\xE2\x80\x9E	bdquo	Low9 Double QUO		Как две запятых, снизу
 * \u201C	\xE2\x80\x9C	ldquo	Left Double QUO		Как две запятых вверх тормашками, сверху
 * \u201D	\xE2\x80\x9D	rdquo	Right Double QUO	Как две запятых, сверху
 * \u2018	\xE2\x80\x98	lsquo	Left Single QUO		Как одна запятая вверх тормашками, сверху
 * \u2019	\xE2\x80\x99	rsquo	Right Single QUO	Как одна запятая, сверху
 *
 * \\x20\\x08\xC2\xA0						Space, Tab, NBSP (RegEx-slashes for system space!)
 */
class UnicodeProcessor
{
	/**
	 * Сущности, которые мы декодируем в обычные символы перед всей прочей
	 * обработкой. Это ограниченный набор символов, которые участвуют
	 * в типографических преобразованиях (т.е., главным образом, кавычки, пробел
	 * и неразрывный пробел (как разделители слов), и т.п.). Все остальные
	 * сущности, которые для нас неважны, мы ни во что не преобразуем и оставляем
	 * как есть (они будут вырезаны и восстановлены как теги).
	 * Формат массива: ключ - запись символа в UTF-8, то есть в той кодировке,
	 * в которой мы обрабатываем текст; значение - массив из названия(ий)
	 * сущности (string) и их числовых кодов в кодировке UCS-2 (integer).
	 * Алгоритм преобразования сам сформирует все нужные regex'ы и для имени
	 * сущности, и для всех числовых форм записи (т.е. и для шестнадцатеричной,
	 * и для десятеричной, и с нулями, и без) - но только если код символа имеет
	 * тип integer.
	 */
	protected $entities = [
		"\xE2\x80\xA6"	=> [0x2026, "&hellip;"],
		"\xC2\xA0"		=> [0x00A0, "&nbsp;"],
		"\x20"			=> [0x0020],
		"\""			=> [0x0022, "&quot;"],
		"\'"			=> [0x0027, "&apos;"],
		"\xE2\x80\x90"	=> [0x2010],
		"\xE2\x80\x91"	=> [0x2011],
		"\xE2\x80\x93"	=> [0x2013, "&ndash;"],
		"\xE2\x80\x94"	=> [0x2014, "&mdash;"],
		"\xC2\xAB"		=> [0x00AB, "&laquo;"],
		"\xC2\xBB"		=> [0x00BB, "&raquo;"],
		"\xE2\x80\xB9"	=> [0x2039, "&lsaquo;"],
		"\xE2\x80\xBA"	=> [0x203A, "&rsaquo;"],
		"\xE2\x80\x9E"	=> [0x201E, "&bdquo;"],
		"\xE2\x80\x9C"	=> [0x201C, "&ldquo;"],
		"\xE2\x80\x9D"	=> [0x201D, "&rdquo;"],
		"\xE2\x80\x98"	=> [0x2018, "&lsquo;"],
		"\xE2\x80\x99"	=> [0x2019, "&rsquo;"],
		"\xE2\x82\xAC"	=> [0x20AC, "&euro;"],
		"\xC2\xA3"		=> [0x00A3, "&pound;"],
		"\xC2\xA9"		=> [0x00A9, "&copy;", "(c)"],
		"\xE2\x84\xA2"	=> [0x2122, "&trade;", "(t)", "(tm)"],
		"\xC2\xAE"		=> [0x00AE, "&reg;", "(r)"],
	];

	// Знаки, перед которым не ставится пробела, и после которых обычно идёт пробел.
	protected $punctuations = [
		".",
		",",
		":",
		";",
		"?",
		"!",
		"\xE2\x80\xA6", // троеточие
	];

	// Знаки кавычек, которые подвергаются реформатированию в форсированном режиме.
	protected $quotations = [
		"\xC2\xAB",
		"\xC2\xBB",
		"\xE2\x80\xB9",
		"\xE2\x80\xBA",
		"\xE2\x80\x9E",
		"\xE2\x80\x9C",
		"\xE2\x80\x9D",
		"\xE2\x80\x98",
		"\xE2\x80\x99",
		"\'", // апостроф
		"\"", // системная кавычка
	];

	// Предлоги, которые идут неразрывно с последующим словом.
	protected $prepositions = [
		'я',
		'ты',
		'мы',
		'вы',
		'он',
		'ее',
		'её',
		'ей',
		'на',
		'не',
		'ни',
		'но',
		'ну',
		'ай',
		'ой',
		'от',
		'ото',
		'ох',
		'до',
		'да',
		'за',
		'из',
		'изо',
		'из-за',
		'по',
		'над',
		'под',
		'при',
		'про',
		'для',
		'без',
		'а',
		'ай',
		'аж',
		'ах',
		'уж',
		'ух',
		'фу',
		'чу',
		'ж',
		'ишь',
		'эк',
		'эка',
		'эко',
		'и',
		'или',
		'у',
		'к',
		'ко',
		'в',
		'во',
		'с',
		'со',
		'о',
		'об',
		'обо',
	];

	// Частицы и сокращения, которые идут неразрывно с предшествующим словом.
	// Учитывать знаки препинания в конце НЕ нужно. Валютные символы сюда
	// не включаем, так как они должны писаться слитно со словом без пробелов;
	// а валютные сокращения - пишем.
	protected $particles = [
		'&mdash;', '%', // потому как ведут себя как частицы в плане неразрывности с предыдущим словом
		'см',
		'кг',
		'км',
		'м',
		'г',
		'гг',
		'г.г',
		'р',
		'руб',
		'ли',
		'ль',
		'же',
		'ж',
		'б',
		'бы',
		'да',
	];

	// Префиксы и суффиксы слов с дефисом, а также численные наращения, которые
	// надо делать неразрывными (пробелы и дефисы). В отличие от предлогов
	// и частиц, префиксы и суффиксы проверяются именно по критерию слитности
	// со словом. Простые написания через точку без пробелов неинтересны
	// (их не модифицируешь); тут только те, что без обработки разорвутся.
	protected $dashword_prefixes = [
		'кое-',
		'кой-',
		'кои-',
		'кто-',
		'чей-',
		'в-',
		'во-',
		'как-',
		'по-',
		'какой-',
	];
	protected $dashword_suffixes = [
		'-ка',
		'-то',
		'-тка',
		'-таки',
		'-либо',
		'-нибудь',
		'-никакой',
		'-ка',
		'-с',
		'-де',
		'-го',
		'-ой',
	];
	protected $dashword_fulltext = [
		'ей-же-ей',
		'из-за',
		'из-под',
		'из-подо',
		'по-над',
		'по-за',
		'да-да',
		'и т. д.',
		'и т. п.',
		'и пр.',
		'т. е.',
		'т. к.',
		'т. о.',
	];
	protected $dashword_augments = [ // комбинации: род+число(же,му,ср,мн) * падеж(име,род,дат,вин,тво,пре) * посл.цифра(1..9); и их краткие варианты.
		"th",
		"nd",
		"rd",
		"st",
		"d",

		"ая",		// же име			12456789
		"ья",		// же име			3
		"ой",		// же род+дат+тво+пре	12456789
		"ей",		// же род+дат+тво+пре	3
		"ую",		// же вин			12456789
		"ью",		// же вин			3
                    
		"ый",		// му име			1459
		"ой",		// му име			2678
		"ий",		// му име			3
		"ого",		// му род+вин		12456789
		"его",		// му род+вин		3
		"ому",		// му дат			12456789
		"ему",		// му дат			3
		"ым",		// му тво			12456789
		"им",		// му тво			3
		"ом",		// му пре			12456789
		"ем",		// му пре			3
                    
		"ое",		// ср име+вин		12456789
		"ье",		// ср име+вин		3
		"ого",		// ср род			12456789
		"его",		// ср род			3
		"ому",		// ср дат			12456789
		"ему",		// ср дат			3
		"ым",		// ср тво			12456789
		"им",		// ср тво			3
		"ом",		// ср пре			12456789
		"ем",		// ср пре			3
                    
		"ые",		// мн име			12456789
		"ьи",		// мн име			3
		"ых",		// мн род+вин+пре	12456789
		"их",		// мн род+вин+пре	3
		"ым",		// мн дат			12456789
		"им",		// мн дат			3
		"ыми",		// мн тво			12456789
		"ими",		// мн тво			3

		"ми",		// =ыми,ими
		"му",		// =ему,ому
		"го",		// =его,ого
		"й",		// =ей,ой,ый,ой,ий
		"я",		// =ая,ья
		"е",		// =ое,ье,ые
		"ю",		// =ую,ью
		"м",		// =ым,им,ом,ем
		"х",		// =ых,их
		"и",		// =ьи (ыми, ими, НО не встречается, ибо бред, от трёх букв так не сокращают)
		"у",		// =(ому,ему, НО не встречается, ибо бред, от трёх букв так не сокращают)
		"о",		// =(его,ого, НО не встречается, ибо бред, от трёх букв так не сокращают)
	];

	// Некоторые частоиспользуемые классы символов (должны срабатывать только
	// на один символ).
	// Пробелы и дефисы сделаны перечислениями, потому что нам не нужно
	// затрагивать действительно все пробелы (пустые, полу и т.п.)
	// и все дефисы (тире, мягкие переносы и т.п.).
	protected $number = "[\\d]";				// только цифры
	protected $symbol = "[\\p{L}\xE2\x80\x90\xE2\x80\x91\\d-]";// буквы, цифры, дефисы (как часть буквопотока в словах)
	protected $letter = "[\\p{L}\xE2\x80\x90\xE2\x80\x91-]";	// только буквы и дефисы, без цифр
	protected $space  = "[\xC2\xA0\\x20\\x08]";		// только пробелы, без переводов строк/параграфов/страниц
	protected $dash   = "[\xE2\x80\x90\xE2\x80\x91-]";		// только дефисы, без тире и переносов

	protected $cut_markup_dictionary; // вспомогательная переменная для общения callback'а с вызывающей функцией; almost stateless.
	protected $put_markup_dictionary; // вспомогательная переменная для общения callback'а с вызывающей функцией; almost stateless.

	protected $use_mdash;
	
	function __construct($use_mdash = false) {
		$this->use_mdash = $use_mdash;
	}
	
	/**
	 * Основная функция по типографскому форматированию текста.
	 *
	 * @param string $text
	 * @param string $language
	 * @param boolean $force_quotes
	 * @return string
	 */
	public function process($text, $language = null, $force_quotes = true) {
		// Декодируем некоторые касающиеся вёрстки сущности, по словарику, во всех формах записи.
		$text = $this->decode_entities($text);

		// Убираем из текста всю разметку, замещая её маркерами и сохраняя её в словарик для будущего восстановления.
		$dictionary = null;// чтобы не ругался что переменная не определена.
		$text = $this->cut_markup($text, $dictionary);

		// Проводим базовую пунктуацию текста.
		$text = $this->punctuate($text);

		// Обрабатываем кавычки в тексте.
		$text = $this->fix_quotes($text, $force_quotes, $language);

		// Обеспечиваем неразрывность слов (с дефисами) и фраз (с предлогами и частицами).
		$text = $this->nobr_words($text);

		// Оптимизируем пробелы.
		$text = $this->optimize_spaces($text);

		// Восстанавливаем в тексте все ранее убранные теги.
		$text = $this->put_markup($text, $dictionary);

		// Возвращаем обработанный текст.
		return $text;
	}

	/**
	 * Функция по замене различных спец-символов, записанных в виде сущностей,
	 * в обычную форму записи; касается только сущностей, важных для
	 * типографского форматирования текста (некоторые пробелы, кавычки и т.п.).
	 *
	 * @param string $text
	 * @return string
	 */
	protected function decode_entities($text) {
		$regex_patterns = $regex_replaces = array();
		foreach ($this->entities as $replacement => $symbols)
		{
			$patterns = array();
			foreach ($symbols as $symbol)
				if (is_integer($symbol)) array_push($patterns, sprintf("&#x0*%X;", $symbol), sprintf("&#0*%d;", $symbol)); else
				if (is_string ($symbol)) array_push($patterns, preg_quote($symbol));
			$regex_patterns[] = "/(" . implode(")|(", $patterns) . ")/sui";//NB: без флага 'x', он портит жизнь.
			$regex_replaces[] = $replacement;
		}
		$text = preg_replace($regex_patterns, $regex_replaces, $text);
		return $text;
	}

	/**
	 * Функция замещения (cut) разметки (тегов и сущностей) специальными
	 * маркерами. После типографирования исходная разметка будет восстановлена
	 * (put) по этим маркерам.
	 * Для замещения используется словарь замен (массив-хеш, ключами которого
	 * являются маркеры, а значениями - замещённые элементы). Сами маркеры
	 * подобраны такими, что по задумке в самом тексте встречаться не должны бы,
	 * и при этом в типографской обработке текста никак не участвуют.
	 *
	 * @param string $text
	 * @param array $dictionary
	 * @return string
	 */
 	protected function cut_markup($text, &$dictionary) {
		// Убираем из текста все элементы разметки (теги и сущности), замещая их специальными маркерами (ключи словаря).
		// При проверке тега учитываются значения атрибутов в кавычках, в том числе то, что символы закрытия тега
		// или символы кавычек могут быть вложены в эти значения, и тогда они не закрывают тег.
		$this->cut_markup_dictionary = array();
		$text = preg_replace_callback("/(< ( (\".*?(?<!\\\\)\") | (\'.*?(?<!\\\\)\') | ([^\'\"]*?) )+ >) | (&(\\#?)[a-zA-Z0-9]+?;) /sux", [__CLASS__, 'cut_markup_callback'], $text);

		// Возвращаем текст с убранной разметкой (заменённой на маркеры), а также словарь соответствия (маркер => разметка).
		$dictionary = $this->cut_markup_dictionary;
		return $text;
	}
	protected function cut_markup_callback($matches) {
		// Генерируем не встречающийся в текстах (а особенно в типографике) маркер для найденного элемента разметки,
		// и замещаем найденную разметку на этот маркер, а саму разметку сохраняем в словарике чтоб позже восстановить.
		$index  = count($this->cut_markup_dictionary);
		$marker = "\xEF\xBF\xBC{$index}\xEF\xBF\xBC";
		$this->cut_markup_dictionary[$marker] = $matches[0];
		return $marker;
	}
	
	/**
	 *  Функция восстановления (put) ранее замещённых маркерам элементов разметки
	 * (тэгов и сущностей).
	 *
	 * @param string $text
	 * @param array $dictionary
	 * @return string
	 */
	protected function put_markup($text, $dictionary) {
		$this->put_markup_dictionary = $dictionary;
		$text = preg_replace_callback("/\xEF\xBF\xBC \\d+ \xEF\xBF\xBC/sux", [__CLASS__, 'put_markup_callback'], $text);
		return $text;
	}
	protected function put_markup_callback($matches) {
		$marker = $matches[0];
		if (array_key_exists($marker, $this->put_markup_dictionary)) return $this->cut_markup_dictionary[$marker];
		return $marker;
	}

	/**
	 * Функция по коррекции знаков препинания и скобок (главным образом,
	 * расстановки пробелов около них), а также по замещению общеупотребительных
	 * последовательностей на типографские символы (тире и т.п.).
	 *
	 * @param string $text
	 * @return string
	 */
	protected function punctuate($text) {
		$space = $this->space;
		$dash = $this->dash;

		$dash_replacement = $this->use_mdash ? "\xE2\x80\x94" : "\xE2\x80\x93"; // mdash or ndash
		
		// Убираем пробелы перед знаками препинания.
		$regex = implode("|", array_map('preg_quote', $this->punctuations));
		$text = preg_replace("/ {$space}+ (?={$regex}) /sxui", "", $text);

		// Убираем пробелы после открывающих и до закрывающих скобок (любых типов).
		//??? а кавычек? хотя кавычки - отдельная тема.
		$text = preg_replace("/ ([\\(\\[\\<]) {$space}+ /sxui", "\\1", $text);
		$text = preg_replace("/ {$space}+ ([\\)\\]\\>]) /sxui", "\\1", $text);

		// Двойные дефисные знаки замещаем на тире независимо от пробелов вокруг,
		// а одинарные -- только если они окружены пробелами (в т.ч. неразрывными).
		// Пробелы до символа делаем одним неразрывным,
		// а вот после него - пока что пишем простой пробел, но в идеале не трогаем никоим образом, только форсируем наличие (сохраняя nbsp).
			//( {$space}*    {$space}+    (?\xE2\x80\x94|\xE2\x80\x93)     (?={$space}) ) |
		$text = preg_replace("/
			( {$space}* (?<!{$dash}) {$dash}{$dash} (?!{$dash} ) ) |
			( {$space}*    {$space}+    {$dash}     (?={$space}) ) |
			( {$space}*    {$space}+    (\xE2\x80\x94|\xE2\x80\x93)     (?={$space}) ) |
			(^{$space}*                 {$dash}     (?={$space}) )
			/sxui", "\xC2\xA0{$dash_replacement}\x20", $text);//NB: именно флаг m, чтоб ловить прямую речь

		// Прямая речь. Оно уже преобразовано в тире, нам нужно только подфиксить пробелы под правильное использование.
		// Прямой речью считаем только тире в начале строки, после которого следуют обязательные пробелы.
		$text = preg_replace("/^ {$space}* {$dash_replacement} {$space}+ /mxui", "{$dash_replacement}\xC2\xA0", $text);

		// Кучу (три и более) подряд идущих точек замещаем одним-единственными типографским многоточием.
		$text = preg_replace("/\\.\\.\\.+/sxui", "\xE2\x80\xA6", $text);

		// Возвращаем что получилось.
		return $text;
	}

	/**
	 * Функция определения языка текста, который влияет на правила типографики.
	 * В данный момент отличает только русский (кириллица) и английский
	 * (латиница) языки. Ориентируется на определённый процент кириллических
	 * символов, так как просто пара-другая таких символов ещё не гарантирует что
	 * текст действительно русский (например, такие символы могут туда попасть
	 * случайно или служить каким-то оформлением, быть цитатой).
	 *
	 * @param string $text
	 * @return string
	 */
	protected function detect_language($text) {
		$all = preg_match("/./sux", $text);//NB: number of chars, not bytes!
		$rus = preg_match("/[\xD0\x81\xD0\x90-\xD0\xAF\xD0\xB0-\xD1\x8F\xD1\x91]/sux", $text);
		$eng = preg_match("/[A-Za-z]/sux", $text);
		$sum = $rus + $eng;
		return ($sum == 0) || ($rus / $sum > 0.01) ? TypographRu::LANGUAGE_RU : TypographRu::LANGUAGE_RU;
	}

	/**
	 * Функция "умной" расстановки и исправления кавычек согласно явно указанному
	 * или автоматически определённому языку. Язык нужно указывать
	 * с использованием константы (TypographRu::LANGUAGE_RU
	 * или TypographRu::LANGUAGE_RU); null означает автоопределение.
	 * Параметр $forced, когда true, заставляет полностью исправить все кавычки,
	 * даже если они уже как-то расставлены; в противном случае (false) будет
	 * оформлять только маркер кавычек (сейчас это системные кавычки, которые
	 * обычно вводятся с клавиатуры при ручном наборе текста).
	 *
	 * @param string $text
	 * @param boolean $forced
	 * @param string $language
	 * @return string
	 */
	protected function fix_quotes($text, $forced = false, $language = null) {
		// Маркер, которым мы замещаем кавычки при принудительном реформате, либо ищем при автоматическом.
		$marker = "\"";// По сути это hard-coded константа, но можно просто здесь заменить, и не менять весь оставшийся код.

		// Проверяем язык, если он нам не указан явно. Используется в расставлении кавычек соответствующей типографики.
		$language = strtolower($language === null ? $this->detect_language($text) : $language);

		// В случае принудительного переформатирования, замещаем все кавычки на спец-маркеры.
		// Учитываем исключение английского языка, когда после апострофа идёт латинская "s" (levi's, branda's...).
		if ($forced)
		{
			$regex = implode("|", array_map('preg_quote', $this->quotations));
			$text = preg_replace("/ (?!'[sS]\\b) ({$regex}) /sux", $marker, $text);
		}

		// Подготавливаем и выполняем цикл преобразования специальных кавычковых маркеров в типографские кавычки (по языку).
		// Работа идёт бинарно, поэтому multibyte ни в каком виде не нужен; хотя его наличие и не повредит.
		$result = ''; $quote_level = 0; 
		$text_len = strlen($text);
		$marker_len = strlen($marker); $marker_pre = -$marker_len;
		while (($marker_pos = strpos($text, $marker, $marker_pre+$marker_len)) !== false)
		{
			// Определяем тип кавычки (открывающая ли это кавычка) по контексту в строке.
			// Мнимо предполагаем что строка с обеих сторон окружена пробелами.
			$lspace = ($marker_pos == 0                      ) || preg_match("/  [\\x20\\x08\xC2\xA0] \$/sux", substr($text, 0, $marker_pos));
			$rspace = ($marker_pos == ($text_len-$marker_len)) || preg_match("/^ [\\x20\\x08\xC2\xA0]   /sux", substr($text, $marker_pos+$marker_len));
			$count  = substr_count($text, $marker, $marker_pos+$marker_len);//WARNING! need PHP>=5.1.0

			// Определяем является ли кавычка открывающей.
			// Для этого сначала определим, является ли она закрывающей, а затем отрицанием получим что нам нужно.
			// А закрывающей кавычка является если, во-первых, вообще есть что закрывать, и во-вторых, хотя бы одно из:
			$opening = !(($quote_level > 0) && (
					// ... если перед кавычкой идёт непробельный символ
					(!$lspace           ) ||
					// ... если кавычка окружена пробелами
					( $lspace && $rspace) ||
					// ... если кавычек осталось только чтобы позакрывать открытые
					($count < $quote_level) // строго меньше, так как мы считаем без учёта текущей кавычки
				));

			// Определяем уровень вложенности кавычки (точнее, чётность уровня), причем в случае открывающей кавычки
			// мы уровень увеличиваем ДО проверки, а в случае закрывающей -- уменьшаем ПОСЛЕ.
			// На основе уровня, типа кавычки и языка текста выбираем её текстовое представление.

			$quote = ($opening?++$quote_level:$quote_level--) % 2 ?
				// кавычки первого уровня (и всех нечётных уровней):
				($language == TypographRu::LANGUAGE_RU ? ($opening ? "\xC2\xAB"     : "\xC2\xBB"    ):
				($language == TypographRu::LANGUAGE_EN ? ($opening ? "\xE2\x80\x9C" : "\xE2\x80\x9D"):
				$marker)):
				// кавычки второго уровня (и всех чётных уровней):
				($language == TypographRu::LANGUAGE_RU ? ($opening ? "\xE2\x80\x9E" : "\xE2\x80\x9C"):
				($language == TypographRu::LANGUAGE_EN ? ($opening ? "\xE2\x80\x98" : "\xE2\x80\x99"):
				$marker));

			// Копируем в результат кусок текста от предыдущей до текущей кавычки и добавляем саму кавычку.
			$result .= substr($text, $marker_pre + $marker_len, $marker_pos - $marker_pre - $marker_len) . $quote;
			$marker_pre = $marker_pos;
		}

		// Копируем в результат кусок текста после последней кавычки (либо весь текст, если ни одной нету).
		$result .= substr($text, $marker_pre+$marker_len);
		return $result;
	}

	/**
	 * Функция по превращению специальных языковых конструкций в неразрывные.
	 * Сначала вспомогательный callback для preg_replace(), который делает текст
	 * неразрывным (касается пробелов и дефисов). А уже затем основная функция,
	 * которая ищет определённые текстовые комбинации в определённых окружающих
	 * контекстах, и заменяет их на неразрывные с помощью этого callback'а.
	 *
	 * @param string $text
	 * @return string
	 */
	protected function nobr_words($text) {
		$symbol = $this->symbol;
		$letter = $this->letter;
		$number = $this->number;
		$dash   = $this->dash  ;
		$space  = $this->space ;

		// ДАЛЕЕ: (про str_replace'ы):
		// Во всех масках заменяем наши программистские обозначения дефисов и пробельных символов (мы их пишем как минус
		// и системный пробел) на выражение со всеми подпадающими под них символами (определены тут же наборами).

		// Слова с дефисами: самостоятельные (1), по префиксу (2), по суффиксу (3), а также числовые наращения (4).
		$regex1 = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->dashword_prefixes));
		$regex2 = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->dashword_suffixes));
		$regex3 = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->dashword_fulltext));
		$regex4 = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->dashword_augments));

		$text = preg_replace_callback("/
			((?<!{$symbol})  ({$regex1}){$symbol}+({$regex2})  (?!{$symbol})) |
			((?<!{$symbol})  ({$regex1}){$symbol}+             (?!{$symbol})) |
			((?<!{$symbol})             {$symbol}+({$regex2})  (?!{$symbol})) |
			((?<!{$symbol})            ({$regex3})             (?!{$symbol})) |
			((?<={$number})    {$dash}*({$regex4})             (?!{$symbol}))
			/suxi", [__CLASS__, 'nobr_words_callback'], $text);

		// ДАЛЕЕ:
		// Последующие выражения не следует объединять с предыдущим, равно как и друг с другом. Это чтобы они срабатывали
		// на весь текст во всех вариантах, и не возникало исключающих коллизий (когда один текст подпадает под одно выражение,
		// но пропускается другим, под которое он тоже должен попасть, но не попадает, потому что попадания взаимоисключающие).

		// Предлоги.
		$regex = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->prepositions));
		$text = preg_replace_callback("/ (?<!{$symbol}) ({$regex}) ({$space})+ /suxi", [__CLASS__, 'nobr_words_callback'], $text);

		// Частицы и общепринятые сокращения.
		$regex = str_replace(array("-", " "), array("({$dash})", "({$space})"), implode("|", $this->particles));
		$text = preg_replace_callback("/ ({$space})+ ({$regex}) (?!{$symbol})  /suxi", [__CLASS__, 'nobr_words_callback'], $text);

		// Число и следующее за ним слово должны быть неразрывны, независимо от того, что это за слово (часть речи),
		// а также от того, разделены ли они пробелом или дефисом (все написания должны быть неразрывным).
		// Фактически покрывает собой числовые наращения к самостоятельным числам (1-ый, 100-ые; кроме мути типа "в-100-ых"),
		// а также частицы и общепринятые сокращения (2008 г., 10 см). Но может нам придётся это выключить когда-нибудь,
		// а неразрывность покрываемых случаев (наращений и частиц) в таком случае всё равно нужно оставить;
		// поэтому они делаются отдельно, а не полагаются на неразрывность числа со словом.
		$text = preg_replace_callback("/
			((?<!{$symbol}) ({$number}+) ({$dash}|{$space})+ (?={$letter}+))
			/suxi", [__CLASS__, 'nobr_words_callback'], $text);

		// Символ № и следующие за ним число делаются неразрывными. И между ними тонкая шпация.
		$text = preg_replace("/
			\xE2\x84\x96 {$space}* ({$number}+)
			/suxi", "\x3C\x6E\x6F\x62\x72\x3E\xE2\x84\x96\xE2\x80\x89$1\x3C\x2F\x6E\x6F\x62\x72\x3E", $text);

		return $text;
	}
	protected function nobr_words_callback($matches) {
		$space = $this->space;
		$dash  = $this->dash;
		// Чёткое и явно указание какие дефисы и какие пробелы превращаять в неразрывные.
		// Тут не стоит полагаться на класс, потому что там может попасть кое-что лишнее (пустые или полу-пробелы и т.п.).
		$text = $matches[0];
		$text = preg_replace("/{$dash} /suxi", "\xE2\x80\x91", $text);
		$text = preg_replace("/{$space}/suxi", "\xC2\xA0"    , $text);
		return $text;
	}

	/**
	 * Функция по оптимизации пробелов в тексте.
	 * Отличается от optimize_tags() тем, что выполняется ещё до того,
	 * как восстановлены исходные теги.
	 *
	 * @param string $text
	 * @return string
	 */
	protected function optimize_spaces($text) {
		// Избавляем неразрывный пробел от окружающих его простых пробелов.
		// Нельзя использовать класс $space (который \\p{Zs}), потому что там ещё подпадают и всякие полу- и пустые пробелы,
		// а нас волнуют именно простые и только они. Хотя это ещё вопрос как оптимизировать такие пробелы (todo??).
		$text = preg_replace("/ [\\x20\\x08]* (\xC2\xA0) [\\x20\\x08]* /suxi", "\xC2\xA0", $text);

		// Много подряд идущих простых пробелов замещаем одним.
		$text = preg_replace("/ [\\x20\\x08]+ /suxi", "\x20", $text);

		return $text;
	}
}

?>
